#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#ifdef WIN32
#include <winsock.h>
#define FDSETCAST (unsigned int)
#define ECONNREFUSED WSAECONNREFUSED
#else
#define FDSETCAST
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <unistd.h>
#include <strings.h>
#include <memory.h>
#include <netdb.h>
#include <signal.h>
#endif

#include <fcntl.h>
#include <errno.h>
#include <math.h>
#include <sys/types.h>
#include <string.h>

#include "vtools.h"
#include "vts_rawtcp.h"

/* #define VTS_EXTREME_DEBUG */

/* our socket read/write operations are non-blocking
 * therefore we need to know the error code that is
 * set, when the operation is timed out:
 * 
 * usually it's EAGAIN. On many systems
 * this is identical to EWOULDBLOCK - but not on all
 * On CRAYs errno is set to EWOULDBLOCK ( != EAGAIN )
 *
 */
#if defined (_CRAY)
#define VTS_BLOCK_ERRNO EWOULDBLOCK
#else
#define VTS_BLOCK_ERRNO EAGAIN
#endif

#define VTS_TCP_SOCKBUFSIZE 1048576  /* the larger, the better ? */

typedef struct {
  int fd;
  int port;
} vts_rawtcp_connection;

int _vts_socket_isinit=0;



#ifdef VTOOLS_PTHREADS

#include <pthread.h>

static pthread_mutex_t _vts_rawtcp_lock=PTHREAD_MUTEX_INITIALIZER;

#define _vts_rawtcp_lock() pthread_mutex_lock(&_vts_rawtcp_lock)
#define _vts_rawtcp_unlock() pthread_mutex_unlock(&_vts_rawtcp_lock)
#else
#define _vts_rawtcp_lock()
#define _vts_rawtcp_unlock()
#endif

/* TCP buffer sizes - will be initialized by vts_socket_init */
static int _vts_rawtcp_sndbuf=-1;
static int _vts_rawtcp_rcvbuf=-1;

/*
 * open a tcp client socket and connect to a server,
 * expected parameters are:
 *   VTS_RAWTCP, char *host, int port, int flag, int timeout, char *text
 * or
 *   VTS_RAWTCP | VTS_TCP_USE_SOCKADDR,
 *            struct sockaddr_in *addr, int flag, int timeout, char *text
 */
int _vts_rawtcp_vclient(vts_connection *vtsc, va_list ap) {
  struct sockaddr_in addr,*addr_ptr;
  int timeout,timeleft,fd,port,ok;
  char *host,*text;
  double t,t0;
  vts_rawtcp_connection *c;

  DPRINTF((2,"_vts_rawtcp_vclient entered\n"));

  if( ! _vts_socket_isinit ) _vts_socket_init();

  if( vtsc->devmod & VTS_TCP_USE_SOCKADDR ) {
    /* caller has provided us with a sockaddr_in structure */
    addr_ptr   = va_arg(ap, struct sockaddr_in *);
    vtsc->flag = va_arg(ap, int);
    timeout    = va_arg(ap, int);
    text       = va_arg(ap, char *);
    if( text && ! *text ) text = "_vts_rawtcp_vclient";

    port = ntohs(addr_ptr->sin_port);
    DPRINTF((2,"_vts_rawtcp_vclient called with sockaddr_in, port=%d\n",port));

  } else {
    /* construct sockaddr_in structure from host/port */
    host       = va_arg(ap, char *);
    port       = va_arg(ap, int);
    vtsc->flag = va_arg(ap, int);
    timeout    = va_arg(ap, int);
    text       = va_arg(ap, char *);
    if( text && ! *text ) text = "_vts_rawtcp_vclient";
    
    DPRINTF((2,"host is >%s<\n",host));
    DPRINTF((2,"port is >%d<\n",port));

    if( ! _vts_rawtcp_sethostaddr(&addr, host, port) ) {
      if( text ) {
	fprintf(stderr,"%s _vts_rawtcp_sethostaddr: %s\n",text, strerror(errno));
      }
      return 0;
    }
   
    DPRINTF((2,"%s: try to connect port %d\n",text ? text : "",port));

    addr_ptr = &addr;
  }
  
  if( (fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
    if( text ) {
      fprintf(stderr,"%s socket: %s\n",text, strerror(errno));
    }
    return 0;
  }

  _vts_rawtcp_tune(fd, text);

  c = (vts_rawtcp_connection *)malloc(sizeof(vts_rawtcp_connection));
  vtools_assert(c, ("out of memory (malloc(%d))",sizeof(vts_rawtcp_connection)));

  vtsc->c    = c;
  c->fd      = fd;
  c->port    = port;

  /* usually connect does not block for a long time, so we don't
   * make our socket non-blocking and poll. Instead, we retry
   * to connect (server may not be up) until we succeed or are
   * timed out.
   */
  DPRINTF((2,"connect(timeout=%d)\n", timeout));
  timeleft = timeout;

  t0 = vtools_dtime(0.);
  do {
    ok = connect(fd, (struct sockaddr *)addr_ptr, sizeof(struct sockaddr_in));
    t = vtools_dtime(t0);
    DPRINTF((2,"connect returned after(t=%f)\n", t));
  } while( (ok!=0) && ((timeleft<0) || (t<timeleft)) );
  if( timeout > 0 ) {
    timeleft = (int) (timeout - 1000*t);
    if( timeleft < 0 ) timeleft = 0;
  }
  if( ok == -1 ) {
    if( text ) {
      fprintf(stderr,"%s connect: %s\n",text, strerror(errno));
    }
    _vts_rawtcp_close(vtsc, text);
    return 0;
  }
  DPRINTF((2,"\t\t\t\t%s: connected\n",text ? text : ""));

  /* socket options, currently just non-blocking */
  if( ! _vts_rawtcp_fcntl(c->fd, vtsc->flag, text) ) {
    _vts_rawtcp_close(vtsc, text);
    return 0;
  }
  
  /* show tunable values */
#ifdef VTOOLS_DEBUG
  if( vtools_isdebug() ) {
    _vts_rawtcp_show_tune(NULL, c->fd);
  }
#endif
  DPRINTF((2, "_vts_rawtcp_vclient: returning with fd=%d\n", c->fd));

  return 1;
}


int _vts_rawtcp_vserver(vts_connection *vtsc, va_list ap) {
  struct sockaddr_in addr;
  visit_socklen_t addr_size;
  char *text;
  vts_rawtcp_connection *c;

  if( ! _vts_socket_isinit ) _vts_socket_init();

  c = (vts_rawtcp_connection *)malloc(sizeof(vts_rawtcp_connection));
  vtools_assert(c, ("out of memory (malloc(%d))",sizeof(vts_rawtcp_connection)));

  vtsc->c = c;
  c->fd   = -1;

  if( vtsc->devmod & VTS_TCP_USE_SOCKET ) {
    c->fd      = va_arg(ap, int);
    vtsc->flag = va_arg(ap, int);
    text       = va_arg(ap, char *);
    if( text && ! *text ) text = "_vts_rawtcp_vserver";
  } else {
    int fd;

    c->port    = va_arg(ap, int);
    vtsc->flag = va_arg(ap, int);
    text       = va_arg(ap, char *);
    if( text && ! *text ) text = "_vts_rawtcp_vserver";

    /* create a socket */
    if( (fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
      if( text ) {
	fprintf(stderr,"%s socket: %s\n", text, strerror(errno));
      }
      _vts_rawtcp_close(vtsc, text);
      return 0;
    }
    c->fd = fd;

    /* and bind it */
    DPRINTF((2,"_vts_rawtcp_vserver: binding socket\n"));
    c->port--;
    do {
      c->port++;
      DPRINTF((2,"_vts_rawtcp_vserver: try to  bind socket to port %d\n",c->port));
      memset (&addr, 0, sizeof addr);
      addr.sin_family = AF_INET;
#ifndef WIN32
      addr.sin_port = htons (c->port);
#else
      addr.sin_port = htons ( (unsigned short)(c->port));
#endif
      addr.sin_addr.s_addr = htonl (INADDR_ANY);
    } while( bind (fd, (struct sockaddr*) &addr, sizeof addr) == -1 );
    
    addr_size = sizeof addr;
    if (getsockname (fd, (struct sockaddr*) &addr, &addr_size) == -1) {
      if( text ) {
	fprintf(stderr,"%s getsockname: %s\n", text, strerror(errno));
      }
      _vts_rawtcp_close(vtsc, text);
      return 0;
    }
    c->port = ntohs(addr.sin_port);
    DPRINTF((2,"_vts_rawtcp_vserver: socket bound to port %d\n",c->port));

    _vts_rawtcp_tune(fd, text );

    if( listen (fd, 5) == -1) {
      if( text ) {
	fprintf(stderr,"%s listen: %s", text, strerror(errno));
      }
      _vts_rawtcp_close(vtsc, text);
      return 0;
    }
    DPRINTF((10,"_vts_rawtcp_vserver: OK done\n"));

  }

  /* socket options, currently just non-blocking
  if( ! _vts_rawtcp_fcntl(c->fd, vtsc->flag, text) ) {
    _vts_rawtcp_close(vtsc, text);
    return 0;
  }
  */

  return 1;
}


/*
 * close a tcp connection and free all data-structures
*/
int _vts_rawtcp_close(vts_connection *vtsc, char *text) {
  int fd;

  /* be paranoid in checking parameters here, this function
   * may be called with already closed or never completely open connection
   */
  if( (! vtsc) || (! vtsc->c) ) return 0;
  fd = ((vts_rawtcp_connection *)vtsc->c)->fd;
  if( fd >= 0 ) {
    DPRINTF((2, " _vts_rawtcp_close: closing fd = %d\n", fd));
#ifndef WIN32
    close(fd);
#else
    closesocket(fd);
#endif
  }
  free(vtsc->c);
  vtsc->c = NULL;

  return 1;
}


/* accept a connection
 *
 * try to accept a connection on a non-connected server
 * returns after at most timeout milliseconds
 * negative timeouts result in blocking calls
 * timeout is ignored for blocking connections
 *
 * if flag is set to VTS_SINGLE_SERVER, the server closes the
 * listening socket after a client has successfully connected
 * in that case, the connection is accessible with the
 * same vts_connection *, otherwise a new vts_connection
 * is created and returned
 *
 * returns: a pointer to the new vts_connection
 *          NULL if no connection is established
 *           or a error occurs
 */
vts_connection *_vts_rawtcp_accept(vts_connection *vtsc, int timeout, char *text) {
  int newfd;
  vts_connection *newvtsc;
  vts_rawtcp_connection *newc,*c;

  c = vtsc->c;

  if( (newfd = _vts_rawtcp_raw_accept(c->fd, timeout, text)) < 0 ) return NULL;

  DPRINTF((2,"_vts_rawtcp_accept: after accept\n"));

  _vts_rawtcp_tune(newfd, text);

  /* socket options, currently just non-blocking */
  if( ! _vts_rawtcp_fcntl(newfd, vtsc->flag, text) ) {
#ifndef WIN32
    close(newfd);
#else
    closesocket(newfd);
#endif
    _vts_rawtcp_close(vtsc, text);
    return NULL;
  }

  newvtsc=(vts_connection *)malloc(sizeof(vts_connection));
  vtools_assert(vtsc,("out of memory (malloc(%d))",sizeof(vts_connection)));

  newc = (vts_rawtcp_connection *)malloc(sizeof(vts_rawtcp_connection));
  vtools_assert(newc, ("out of memory (malloc(%d))",sizeof(vts_rawtcp_connection)));

  newvtsc->device = vtsc->device;
  newvtsc->devmod = vtsc->devmod;
  newvtsc->server = 0;
  newvtsc->flag   = vtsc->flag;
  newvtsc->size   = 1;
  newvtsc->rank   = 0;
  newvtsc->c      = newc;

  newc->fd   = newfd;
  newc->port = c->port;

  return newvtsc;
}

/*
 * just a non-blocking accept, that returns a connected and tuned socket
 * (or -1 on error)
 */
int _vts_rawtcp_raw_accept(int fd, int timeout, char *text) {

  int newfd;
#ifdef HAS_SELECT
  /* if no selct is available, we simply ignore the timeout and block */

  if( timeout >= 0 ) {
    /* accept the pending connection:
     * we don't want to poll, if a timeout was specified,
     * so we use select to wait for a client
     */
    fd_set rfds;
    struct timeval tv,*tvptr;

    FD_ZERO(&rfds);
    FD_SET( FDSETCAST fd, &rfds);

    tv.tv_sec  = timeout / 1000;  /* timeout is in msec */
    tv.tv_usec = 1000*(timeout % 1000);
    tvptr = &tv;

    DPRINTF((2,"_vts_rawtcp_accept: before select fd=%d\n",fd));

    if( select(fd+1, &rfds, NULL, NULL, tvptr) ) {
      DPRINTF((2,"_vts_rawtcp_accept: before accept fd=%d\n",fd));
      if( (newfd = accept (fd, NULL, 0)) < 0 ) {
	if( text ) {
	  fprintf(stderr, "%s: (errno=%d) %s\n", text, errno, strerror(errno));
	}
	return -1;
      }
    } else {
      return -1;
    }
  } else
#endif
    {
    /* timeout < 0 */
    DPRINTF((2,"_vts_rawtcp_accept: before blocking accept fd=%d\n",fd));
    if( (newfd = accept (fd, NULL, 0)) < 0 ) {
      if( text ) {
	fprintf(stderr, "%s: (errno=%d) %s\n", text, errno, strerror(errno));
      }
      DPRINTF((2,"_vts_rawtcp_accept: newfd=%d (errno=%d) %s\n", newfd, errno, strerror(errno)));
      return -1;
    }
  }

  DPRINTF((2,"_vts_rawtcp_accept: after accept newfd=%d\n", newfd));

  return newfd;
}


/* send data
 *
 * try to write size byte from data into socket
 * returns after at most timeout milliseconds
 * negative timeouts result in blocking calls
 * timeout is ignored for blocking connections
 *
 * (rank is ignored)
 *
 * returns: the number of bytes written
 *          0 timed out with 0 byte written
 *         -1 error
 */
int _vts_rawtcp_send(vts_connection *vtsc, int rank, const void *data, int size, int timeout, char *text) {
  vts_rawtcp_connection *c = vtsc->c;

  return _vts_rawtcp_raw_send(c->fd, data, size, timeout, text);
}


int _vts_rawtcp_raw_send(int fd, const void *data, int size, int timeout, char *text) {
  int n_left,n_send,a;
  const char *cdata=data;
  double t0,t;
#ifdef WIN32
  int win32err=0;
#endif

  DPRINTF((1024,"%s: try to write size=%d\n",text ? text : "",size)); 

  n_left = size;
  n_send = 0;

  t0 = vtools_dtime(0.);

  while(1) {
    a = send(fd, cdata, n_left, 0);

    DPRINTF((1024,"%s: \t n_left=%d a=%d\n",text ? text : "",n_left,a));

    if( a == -1 ) {
#ifndef WIN32
      if( (errno == EINTR || errno == VTS_BLOCK_ERRNO) ) {
	a=0;
      }
#else
      win32err=WSAGetLastError();
      if( (win32err == WSAEINTR || win32err == WSAEWOULDBLOCK) ) {
	a=0;
      }
#endif
      else {
	DPRINTF((2,"%s: fd=%d data=%x (cdata=%x) size=%d n_left=%d send=%d\n",
		 text ? text : "", fd, (unsigned)(size_t)data,
		 (unsigned)(size_t)cdata,size,n_left,cdata-(char *)data));
	if( text ) {
	  fprintf(stderr, "%s: %s\n", text, strerror(errno));
	}
	return -1;
      }
    }
    n_left -= a;
    n_send += a;
    cdata  += a;

    t = vtools_dtime(t0);

    if( (n_left == 0) || ((timeout >= 0) && (1000.*t >= timeout)) ) {
      return n_send;
    }
  }
}


/* receive data
 *
 * try to read size byte from socket sd into data
 * returns after at most timeout milliseconds
 * negative timeouts result in blocking calls
 * timeout is ignored for blocking connections
 *
 * (rank is ignored)
 *
 * returns: number of bytes read
 *          0 timed out with 0 bytes read
 *         -1 error
 *
 */
int _vts_rawtcp_recv(vts_connection *vtsc, int *rank, void *data, int size,
		     int timeout, char *text) {
  int pollflag;

  vts_rawtcp_connection *c = vtsc->c;

  /* shall we poll on this connection ? */
  pollflag = vtsc->flag & VTS_POLL ? 1 : 0;

  return _vts_rawtcp_raw_recv(c->fd, data, size, pollflag, timeout, text);
}


int _vts_rawtcp_raw_recv(int fd, void *data, int size,
			 int pollflag, int timeout, char *text) {
  int n_left,n_read,a;
  char *cdata=data;
  double t0,t;
#ifdef WIN32
  int win32err=0;
#endif

#define VTS_EXTREME_DEBUG
#ifdef VTS_EXTREME_DEBUG
  DPRINTF((2,"%s: try to read size=%d (timeout=%d)\n",text ? text : "",size, timeout)); 
#endif

  n_left = size;
  n_read = 0;

  t0 = vtools_dtime(0.);

  for(;;) {
    if( ! pollflag ) {
      int timeleft,ok;

      timeleft = _vts_get_timeleft(timeout, t0);
      if( (ok=_vts_rawtcp_wait_for(fd, timeleft, text)) < 0 ) return -1;
      if( ok == 0 ) return n_read;
    }
    a = recv (fd, cdata, n_left, 0);

    if( a == 0 ) {
      /* only dead sockets return 0 */
      if( text ) {
	fprintf(stderr, "%s: sockets broken after reading %d of %d bytes\n",
		text, size-n_left, size);
      }
      DPRINTF((2,"%s: returning with error '%s'\n",text ? text : "",
	       strerror(errno)));
      return n_read > 0 ? n_read : -1; /* nevertheless, we might have read something already */
    } else if( a == -1 ) {
      /* timeouts, or interrupts by signals */
#ifndef WIN32 
      if( (errno == EINTR || errno == VTS_BLOCK_ERRNO) ) {
#ifdef VTS_VERY_EXTREME_DEBUG
	DPRINTF((2,"%s: \t errno = %s, setting a=0\n",text ? text : "",
		 (errno==EINTR) ? "EINTR" : "VTS_BLOCK_ERRNO"));
#endif
	a=0;
      }
#else
      win32err=WSAGetLastError();
      if( (win32err == WSAEINTR || win32err == WSAEWOULDBLOCK) ) {
	a=0;
      }
#endif
      else {
	if( text ) {
	  fprintf(stderr, "%s: %s\n",text, strerror(errno));
	}
	DPRINTF((2,"%s: returning with error '%s'\n",text ? text : "",
		 strerror(errno)));
	return -1;
      }
    }
    n_left -= a;
    n_read += a;
    cdata  += a;

    t = vtools_dtime(t0);
#ifdef VTS_EXTREME_DEBUG
    DPRINTF((2,"%s: \t n_left=%d a=%d t=%lf timeout=%d\n",
	     text ? text : "",n_left,a,t, timeout));
#endif

    if( (n_left == 0) || ((timeout >= 0) && (1000.*t >= timeout)) ) {
#ifdef VTOOLS_DEBUG
      if( n_read != 0 ) {
	DPRINTF((2,"%s: returning with  n_left=%d n_read = %d\n",text ? text : "",
	       n_left,n_read));
      }
#endif
      return n_read;
    }
  }
}


int _vts_rawtcp_get_fd(vts_connection *vtsc, int rank, char *text) {
  vts_rawtcp_connection *c = vtsc->c;

  if( !c || (rank!=0) ) return -1;

  return c->fd;
}

int _vts_rawtcp_get_port(vts_connection *vtsc, char *text) {
  vts_rawtcp_connection *c = vtsc->c;

  return  c ? c->port : -1;
}

vts_connection *_vts_rawtcp_collective(int size, vts_connection **vtsc, char *text) {
  if( size == 1 ) {
    return vtsc[0];
  } else {
    return NULL;
  }
}

int _vts_rawtcp_set_fd_set(vts_connection *vtsc, fd_set *fds, char *text) {
  return -1;
}
int _vts_rawtcp_fd_isset(vts_connection *vtsc, fd_set *fds, char *text) {
  return -1;
}
int _vts_rawtcp_after_raw_accept(vts_connection *vtsc, int newfd, int timeout, char *text) {
  return -1;
}

/*
 *  non-public support functions
 *
 */

void _vts_socket_init(void) {

  _vts_rawtcp_lock();

  if( ! _vts_socket_isinit ) {
#ifdef WIN32
    /*
     * on Windows with WINSOCK2
     * the following code must be executed
     * once, before sockets can be used
     */
    WSADATA wsadata;

    DPRINTF((2,"WSAStartup ...\n"));

    if(WSAStartup(0x202,&wsadata)==SOCKET_ERROR) {
      fprintf(stderr,"WSAStartup failed with error %d",WSAGetLastError());
      WSACleanup();
      _vts_rawtcp_unlock();
      return;
    }
#else
    /* on UNIX systems, a broken socket generates a
     * signal that kills the process by default
     * Unless the user has changed that behaviour
     * we choose to ignore the SIG_PIPE signal
     */
    static void (*old_handler) (int) = SIG_ERR;

    if( old_handler == SIG_ERR ) {
      old_handler = signal(SIGPIPE, SIG_IGN);
      if( (old_handler != SIG_DFL) && (old_handler != SIG_IGN) ) {
	fprintf(stderr, "Warning: non-default signal handler for SIGPIPE NOT deinstalled\n");
	signal(SIGPIPE, old_handler);
      }
    }
#endif

    /* fetch buffer sizes from rc-file */
    if( _vts_rawtcp_sndbuf < 0 ) {
      if( ! vtools_rc_get_int("tcp_sndbuf", &_vts_rawtcp_sndbuf) ) {
	_vts_rawtcp_sndbuf = VTS_TCP_SOCKBUFSIZE;
      }
      if( ! vtools_rc_get_int("tcp_rcvbuf", &_vts_rawtcp_rcvbuf)) {
	_vts_rawtcp_rcvbuf = VTS_TCP_SOCKBUFSIZE;
      }
    }

    _vts_socket_isinit = 1;
  }
  _vts_rawtcp_unlock();
  return;
}

void _vts_rawtcp_show_tune(FILE *out, int fd) {
  visit_socklen_t optval[3],optsize;

  if( ! out ) out = vtools_get_dfile();

  if( ! out ) return;

  optsize=sizeof(optval);
  if(getsockopt(fd,SOL_SOCKET,SO_SNDBUF,(void *)optval,&optsize) <0) {
    perror("setsockopt - SO_SNDBUF");
  } else {
    fprintf(out,"socket=%d\t(%d)\tSO_SNDBUF=%d\n",fd,(int)optsize,(int)optval[0]);
  }

  optsize=sizeof(optval);
  if(getsockopt(fd,SOL_SOCKET,SO_RCVBUF,(void *)optval,&optsize) <0) {
    perror("getsockopt - SO_RCVBUF");
  } else {
    fprintf(out,"socket=%d\t(%d)\tSO_RCVBUF=%d\n",fd,(int)optsize,(int)optval[0]);
  }

#if defined(_CRAY)
  optsize=sizeof(optval);
  if(getsockopt(fd,IPPROTO_TCP,TCP_WINSHIFT,(void *)optval,&optsize) <0) {
      perror("getsockopt - TCP_WINSHIFT");
  } else {
    fprintf(out,"socket=%d\t(%d)\tTCP_WINSHIFT=%d\n",fd,(int)optsize,(int)optval[1]);
  }
#endif
#if defined(_AIX)
  if(getsockopt(fd,IPPROTO_TCP,TCP_RFC1323,(void *)&optval,&optsize) <0) {
      perror("getsockopt - TCP_RFC1323");
  } else {
    fprintf(out,"socket=%d\t(%d)\tTCP_RFC1323=%x\n",fd,(int)optsize,(unsigned)optval[0]);
  }
#endif
#ifndef WIN32 
   optsize=sizeof(optval);
  if(getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG,
		(void *)&optval, &optsize) < 0) {
    perror("getsockopt - TCP_MAXSEG:");
  } else {
    fprintf(out,"socket=%d\t(%d)\tTCP_MAXSEG=%d\n",fd,(int)optsize,(int)optval[0]);
  }
#endif

  optsize=sizeof(optval);
  if(getsockopt(fd, IPPROTO_TCP, TCP_NODELAY,
		(void *)&optval, &optsize) < 0) {
    perror("getsockopt - TCP_NODELAY:");
  } else {
    fprintf(out,"socket=%d\t(%d)\tTCP_NODELAY=%x\n",fd,(int)optsize,(int)optval[0]);
  }
  return;
}


/*
 * TCP socket tuning with default values
 * (as defined at top of this file)
 */
int _vts_rawtcp_tune(int fd, char *text) {
  int optval;

  fprintf(stderr, " _vts_rawtcp_tune %d %d ...\n", _vts_rawtcp_sndbuf, _vts_rawtcp_rcvbuf);

  /* TCP socket-buffer size: large buffers offer the ability to
     send/recv large amounts of data without blocking the sender
     until the receiver has read and acknowledged the data

     Newer Linux kernel have auto-tuning capabilities, which is
     turned off, when buffers are set manually.
     Therefore: buffers are not tuned manually, if tcp_sndbuf:0 in .visitrc
  */
  if( _vts_rawtcp_sndbuf ) {
    optval = _vts_rawtcp_sndbuf;
    if(setsockopt(fd, SOL_SOCKET,SO_SNDBUF,(char *)&optval,sizeof(optval)) <0) {
      perror("setsockopt - SO_SNDBUF");
    }
  }
  if( _vts_rawtcp_rcvbuf ) {
    optval = _vts_rawtcp_rcvbuf;
    if(setsockopt(fd,SOL_SOCKET,SO_RCVBUF,(char *)&optval,sizeof(optval)) <0) {
      perror("setsockopt - SO_RCVBUF");
    }
  }
  /* send keepalive messages - otherwise we will not know, that the remote side
   * has disconnected, until we try to read or write something
   */
  optval =1;
  if(setsockopt(fd,SOL_SOCKET,SO_KEEPALIVE,(char *)&optval,sizeof(optval)) <0) {
    perror("setsockopt - SO_KEEPALIVE");
  }

  /* using this option (RFC 1323) offers the ability to negotiate
     a TCP-window that is larger than 64KB, which makes better use
     of large TCP buffers.
     This is only neccessary for CRAY, other systems use the given
     buffer-size to negotiate a proper window shift.
  */
#if defined(_CRAY)
    optval = TCP_WINSHIFTVAL;
    if(setsockopt(fd,IPPROTO_TCP,TCP_WINSHIFT,(char *)&optval,sizeof(optval)) <0) {
      perror("setsockopt - TCP_WINSHIFT");
    }
#endif
  /* for AIX RFC1323-support can be enabled by the application */
#if defined(_AIX)
    optval=1;
    if(setsockopt(fd,IPPROTO_TCP,TCP_RFC1323,(char *)&optval,sizeof(optval)) <0) {
      perror("setsockopt - TCP_RFC1323");
    }
#endif

  /* write data to the network immediately. without this option
     the system will wait for more data to fill the MTU-size up to
     200 msec
  */
  optval=1;
  if(setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void *)&optval, sizeof(optval)) < 0) {
    perror("setsockopt - TCP_NODELAY");
  }

  return 1;
}


/* socket options, currently just non-blocking */

int _vts_rawtcp_fcntl(int fd, int flag, char *text) {
#ifdef HAS_FCNTL
  if( flag ) {
    int fcntl_arg=0;
#ifdef WIN32
    unsigned long argp;

    argp=0;
    if( flag & VTS_NONBLOCK ) argp = 1;

    /* WF: WARNING setting to BLOCKING (0) fails on WIN32 when using AVS/Express */

    if( ioctlsocket(fd, FIONBIO,&argp) != 0) {
      if( text ) {
	fprintf(stderr,"%s fcntl: %s WSA=%d\n",text, strerror(errno), WSAGetLastError());
      }
      return 0;
    }
#else
    if( flag & VTS_NONBLOCK ) fcntl_arg |=  O_NONBLOCK;
    if( fcntl(fd, F_SETFL, fcntl_arg) < 0) {
      if( text ) {
	fprintf(stderr,"%s fcntl: %s\n",text, strerror(errno));
      }
      return 0;
    }
#endif
  }
#endif
  return 1;
}


int _vts_rawtcp_eof(int fd, char *text) {
#ifdef HAS_SELECT
  fd_set e;
  struct timeval tv;
  int nsel;
  if( text && ! *text ) text = "_vts_rawtcp_eof";

  tv.tv_sec  = 0;
  tv.tv_usec = 0;

  FD_ZERO(&e);
  FD_SET( FDSETCAST fd, &e);
  nsel = select(fd+1, &e, NULL, NULL, &tv);

  DPRINTF((2,"_vts_rawtcp_eof: select returned with nsel=%d\n", nsel));
#endif
  return 0;
}


/* convenience function:
   wait for input from a socket descriptor
   @param fd socket descriptor
   @param timeout max time to wait in milliseconds
   @return 1, if something is available
           0, if not
          -1, in case of an error
*/
int _vts_rawtcp_wait_for(int fd, int timeout, char *text) {
  fd_set rfds,efds;
  int ret,timeleft=0;
  double t0=0.;

  FD_ZERO(&rfds);
  FD_ZERO(&efds);
  FD_SET(FDSETCAST fd, &rfds);
  FD_SET(FDSETCAST fd, &efds);

  if( timeout >= 0 ) {
    t0 = vtools_dtime(0.);
    timeleft = timeout;
  }
  DPRINTF((2, "_vts_rawtcp_wait_for(timeout=%d, timeleft=%d)\n", timeout, timeleft));

  do {
    if (timeout < 0) {
#ifdef HAS_SELECT
      ret = select(fd+1, &rfds, NULL, &efds, NULL);   /* wait indefinitely for data */
#else
      ret = 1;
#endif
    } else {
#ifdef HAS_SELECT
      struct timeval stime;
   
      stime.tv_sec=timeleft/1000;
      stime.tv_usec=(timeleft%1000)*1000;
      ret = select(fd+1, &rfds, NULL, &efds, &stime); /* wait for data available */
#else
      ret = 1;
#endif

      timeleft = _vts_get_timeleft(timeout,t0);
    }
  } while ((ret == -1) && (errno == EINTR) && (timeleft != 0) );

  if (ret == -1) {
    if( text ) {
      fprintf(stderr,"%s: error in select : '%s' (errno=%d)\n",
	      text, strerror(errno), errno);
    }
  } else if ((ret == 0) && (timeout > 0)) {
    DPRINTF((2, "\n*******************\nT: no data available within %d mseconds\n\n",
	     timeout));
  }
  DPRINTF((2, "returning with timeout=%d timeleft=%d\n", timeout, timeleft));
  return ret;
}

/*
 * resolve a hostname and set the addr-structure as required
 *
 * (we use gethostbyname if available, otherwise a numeric address is needed)
 */
int _vts_rawtcp_sethostaddr(struct sockaddr_in *addr, char *hostname, int port) {
  struct hostent *hent;

  if( ! _vts_socket_isinit ) _vts_socket_init();

  memset(addr, 0, sizeof(struct sockaddr_in));
  addr->sin_family = AF_INET;
  addr->sin_port = htons ( (unsigned short) port);
  addr->sin_addr.s_addr = htonl (INADDR_ANY);

#ifdef HAS_GETHOSTBYNAME
  if( (hent=gethostbyname(hostname)) == NULL ) {
#ifdef WIN32
    fprintf(stderr, "_vts_rawtcp_sethostaddr gethostbyname('%s') error: %d\n",
	    hostname, WSAGetLastError());
#else
    fprintf(stderr, "_vts_rawtcp_sethostaddr gethostbyname('%s') error: %s\n",
	    hostname, strerror(h_errno));
#endif
    return 0;
  }
  memcpy(&addr->sin_addr, hent->h_addr, hent->h_length);
#else
  {
    int u1,u2,u3,u4;
    if(sscanf(hostname,"%d.%d.%d.%d",&u1,&u2,&u3,&u4)!=4) {
      fprintf(stderr,"_vts_rawtcp_sethostaddr: failed to split seap_server address into numeric parts %s (no gethostbyname available)\n",
	      hostname);
      return 0;
    }
    addr->sin_addr.s_addr= (uint32_t) 
      u1  *256*256*256 +
      u2  *256*256 +
      u3  *256 +
      u4; 
    DPRINTF((1,"vts_rawtcp_sethostaddr: set s_addr to %d.%d.%d.%d\n",u1,u2,u3,u4));
  }
#endif
  return 1;
}
